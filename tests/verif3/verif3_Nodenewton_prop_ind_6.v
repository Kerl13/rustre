(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.

(* Why3 assumption *)
Definition unit := unit.

(* Why3 assumption *)
Inductive state :=
  | mk_state : Z -> Z -> state.
Axiom state_WhyType : WhyType state.
Existing Instance state_WhyType.

(* Why3 assumption *)
Definition out (v:state): Z := match v with
  | (mk_state x x1) => x1
  end.

(* Why3 assumption *)
Definition cpt (v:state): Z := match v with
  | (mk_state x x1) => x
  end.

(* Why3 goal *)
Theorem prop_ind : forall (out__1:Z) (out__2:Z) (t__1:Z) (t__2:Z) (uss:state)
  (uss2:state) (uss3:state), (((out__1 = (out uss)) /\ let cpt1 :=
  (cpt uss) in
  ((t__1 = (ZArith.BinInt.Z.quot ((cpt1 + (-1%Z)%Z)%Z * cpt1)%Z 2%Z)) /\
  ((((cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z = (2%Z * out__1)%Z) /\
  (((out uss2) = (out__1 + cpt1)%Z) /\ (((cpt uss2) = (cpt1 + 1%Z)%Z) /\
  (((cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z = (2%Z * out__1)%Z) \/
  ((~ ((cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z = (2%Z * out__1)%Z)) /\
  (false = true)))))) \/
  ((~ ((cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z = (2%Z * out__1)%Z)) /\
  (((out uss2) = (out__1 + cpt1)%Z) /\ (((cpt uss2) = (cpt1 + 1%Z)%Z) /\
  (((cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z = (2%Z * out__1)%Z) \/
  ((~ ((cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z = (2%Z * out__1)%Z)) /\
  (false = true))))))))) /\ ((out__2 = (out uss2)) /\ let cpt1 :=
  (cpt uss2) in
  ((t__2 = (ZArith.BinInt.Z.quot ((cpt1 + (-1%Z)%Z)%Z * cpt1)%Z 2%Z)) /\
  ((((cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z = (2%Z * out__2)%Z) /\
  (((out uss3) = (out__2 + cpt1)%Z) /\ ((cpt uss3) = (cpt1 + 1%Z)%Z))) \/
  ((~ ((cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z = (2%Z * out__2)%Z)) /\
  (((out uss3) = (out__2 + cpt1)%Z) /\ ((cpt uss3) = (cpt1 + 1%Z)%Z))))))) ->
  let cpt1 := (cpt uss2) in
  ((((cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z = (2%Z * out__2)%Z) ->
  ((~ ((cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z = (2%Z * out__2)%Z)) ->
  (false = true))) /\
  ((~ ((cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z = (2%Z * out__2)%Z)) ->
  ((~ ((cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z = (2%Z * out__2)%Z)) ->
  (false = true)))).
intros out__1 out__2 t__1 t__2 uss uss2 uss3 ((h1,h2),(h3,h4)) cpt1.

split; eauto.
intros.
rename cpt1 into a.
intuition.
subst.
intuition.
fold a in H6, H2, H5, H9, H, H0, H4, H7.
pose (cpt uss).
fold z in  H6, H2, H5, H9, H, H0, H4, H7.
rewrite H6 in H2.
assert (2* (out uss + z) = 2*out uss + 2*z)%Z.
omega.
rewrite H10 in H2.
rewrite <-H9 in H2.
clear H. clear H0.
fold a in H8.
fold z in H8.
rewrite H8 in H2.

assert (z+1 + - (1) = z+ -1 + 1)%Z.
omega.
rewrite H in H2.
assert ((z + 1)*(z+ -1 + 1) = (z+1)*(z+-1) + (z+1))%Z.
Require Import Coq.micromega.Lia.
lia.
rewrite H0 in H2.
assert ((z+1)*(z+-1) = z*(z+-1)+(z+-1))%Z.
lia.
rewrite H11 in H2.
assert (z * (z + -1) + (z+-1)+(z+1) = (z * (z + -1) + 2*z))%Z.
lia.
rewrite H12 in H2.
assert (z+-1 = z+-(1))%Z.
lia.
rewrite H13 in H2.
pose (H2 eq_refl).
eauto.
Qed.