(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.

(* Why3 assumption *)
Definition unit := unit.

(* Why3 assumption *)
Inductive state :=
  | mk_state : Z -> Z -> state.
Axiom state_WhyType : WhyType state.
Existing Instance state_WhyType.

(* Why3 assumption *)
Definition out (v:state): Z := match v with
  | (mk_state x x1) => x1
  end.

(* Why3 assumption *)
Definition cpt (v:state): Z := match v with
  | (mk_state x x1) => x
  end.

(* Why3 goal *)
Theorem prop_ind : forall (out__1:Z) (out__2:Z) (t__1:Z) (t__2:Z) (uss:state)
  (uss2:state) (uss3:state), (((out__1 = (out uss)) /\ let cpt1 :=
  (cpt uss) in
  ((t__1 = (ZArith.BinInt.Z.quot ((cpt1 + (-1%Z)%Z)%Z * cpt1)%Z 2%Z)) /\
  ((((ZArith.BinInt.Z.quot (cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z 2%Z) = out__1) /\
  (((out uss2) = (out__1 + cpt1)%Z) /\ (((cpt uss2) = (cpt1 + 1%Z)%Z) /\
  (((ZArith.BinInt.Z.quot (cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z 2%Z) = out__1) \/
  ((~ ((ZArith.BinInt.Z.quot (cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z 2%Z) = out__1)) /\
  (false = true)))))) \/
  ((~ ((ZArith.BinInt.Z.quot (cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z 2%Z) = out__1)) /\
  (((out uss2) = (out__1 + cpt1)%Z) /\ (((cpt uss2) = (cpt1 + 1%Z)%Z) /\
  (((ZArith.BinInt.Z.quot (cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z 2%Z) = out__1) \/
  ((~ ((ZArith.BinInt.Z.quot (cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z 2%Z) = out__1)) /\
  (false = true))))))))) /\ ((out__2 = (out uss2)) /\ let cpt1 :=
  (cpt uss2) in
  ((t__2 = (ZArith.BinInt.Z.quot ((cpt1 + (-1%Z)%Z)%Z * cpt1)%Z 2%Z)) /\
  ((((ZArith.BinInt.Z.quot (cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z 2%Z) = out__2) /\
  (((out uss3) = (out__2 + cpt1)%Z) /\ ((cpt uss3) = (cpt1 + 1%Z)%Z))) \/
  ((~ ((ZArith.BinInt.Z.quot (cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z 2%Z) = out__2)) /\
  (((out uss3) = (out__2 + cpt1)%Z) /\ ((cpt uss3) = (cpt1 + 1%Z)%Z))))))) ->
  let cpt1 := (cpt uss2) in
  ((((ZArith.BinInt.Z.quot (cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z 2%Z) = out__2) ->
  ((~ ((ZArith.BinInt.Z.quot (cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z 2%Z) = out__2)) ->
  (false = true))) /\
  ((~ ((ZArith.BinInt.Z.quot (cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z 2%Z) = out__2)) ->
  ((~ ((ZArith.BinInt.Z.quot (cpt1 * (cpt1 + (-1%Z)%Z)%Z)%Z 2%Z) = out__2)) ->
  (false = true)))).
intros out__1 out__2 t__1 t__2 uss uss2 uss3 ((h1,h2),(h3,h4)) cpt1.
split; eauto.
intros.
simpl in * |- *.
rename cpt1 into a.
intuition.
subst.
fold a in H6, H10, H2, H5, H9, H, H0, H4, H7.
pose (cpt uss).
fold z in  H6, H10, H2, H5, H9, H, H0, H4, H7.
rewrite H5 in H, H0, H4.
rewrite <-H2 in H, H0, H4, H9.
rewrite H6 in H, H0, H4.

assert (z+1 + -1 = z+ -1 + 1)%Z.
omega.
clear H0. clear H4.
rewrite H1 in H.
assert ((z + 1)*(z+ -1 + 1) = (z+1)*(z+-1) + (z+1))%Z.
Require Import Coq.micromega.Lia.
lia.
rewrite H0 in H.
assert ((z+1)*(z+-1) = z*(z+-1) + z+-1)%Z.
lia.
rewrite H3 in H.
simpl in H.
assert ((z * (z + -1) + z + -1 + (z + 1)) = ((z * (z + -1) + 2*z)))%Z.
lia.
rewrite H4 in H.
assert ((z * (z + -1) + 2 * z) = z*(z+-1) + 2*z)%Z.
lia.
omega.

omega.

fold z in H.



Qed.

